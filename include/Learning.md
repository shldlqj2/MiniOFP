# 학습 정리

해당 문서는 gemini의 도움을 받아 MiniOFP를 만드는 과정에서 생긴 의문을 정리해놓은 문서 입니다.

----------

1. std::vector::push_back의 내부 동작(메모리 이사)

- 초기에 데이터 2개짜리 메모리를 잡는다.

- 데이터가 2개보다 많이 들어오면 2개로 부족하다고 판단 -> 새로운 메모리를 할당 받고 해당 메모리로 모든 데이터 복사 후 원래 데이터 free

- 당연히 오버헤드가 발생. 벡터의 대략적인 크기를 안다면, reserve()를 통해 적당한 크기를 잡아놓는다면 성능적으로 유리하다.

1. NavDB.h에서 findAirport함수가 주소를 반환하는 이유

- "효율성"과 "존재 여부 확인"때문

- 값을 반환 하는 방식으로 한다면 이름,좌표 등 데이터를 복사해서 새로운 값을 만들어 제공 -> 데이터가 크면 느려짐

- 반면, 포인터를 반환한다면 해당 메모리 주소를 알려줌으로 복사비용이 0 (오버헤드가 낮음)

1. MTOW에 연료무게를 포함하는 이유: 연료는 온도에 따라 부피가 변하기 때문에 연료무게가 일정 할 수 없다.

2. 생성자에서 함수:인자1(전달 인자1)과 같은 방식으로 초기화 하는 이유는 오버헤드를 줄이기 위해. + const멤버 변수나 참조자는 이 방식으로만 초기화 해야한다.
